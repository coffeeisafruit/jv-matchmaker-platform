TITLE: THE EXECUTION GAP: ARCHITECTING A CHALLENGER CO-SELL PLATFORM WITH DJANGO AND THE HAT STACK1. Executive Summary: The Consolidation Trap and the Execution VacuumThe landscape of Partner Ecosystem Platforms (PEPs) has undergone a fundamental transformation, culminating in the merger of Crossbeam and Reveal. This consolidation has created a market "Supernode"â€”a dominant entity possessing immense data gravity and a vast network of interconnected companies. While this validated the category of ecosystem-led growth (ELG), it simultaneously introduced significant market friction. As the incumbent moves upmarket to service large enterprise requirements with generalized "data escrow" solutions, a critical "execution gap" has emerged for the mid-market and vertical-specific SaaS companies.1Current market feedback indicates that while users have gained visibility into account overlapsâ€”knowing, for instance, that a prospect is a customer of a partnerâ€”they face substantial barriers in translating this intelligence into revenue. The prevailing platforms have become "Read-Only" dashboards where data is viewed but not acted upon. Users report disjointed workflows where they must toggle between the ecosystem platform, their CRM, Slack, and email to initiate a simple partner introduction or co-selling motion. Furthermore, the pricing models of the major players, often predicated on "connector" fees or platform taxes that scale with partner count, have priced out agile teams and smaller independent software vendors (ISVs).4This report presents a comprehensive strategic and technical blueprint for developing a Co-Sell Execution Platform designed to exploit this gap. The proposed solution leverages a specific, high-performance technology stackâ€”Django, HTMX, Alpine.js, and Tailwind CSS (the HAT stack)â€”to deliver "radical simplicity" and high throughput without the overhead of complex Single Page Applications (SPAs).The strategy detailed herein pivots on the concept of the "Wedge." Rather than attempting a frontal assault on the incumbent's network effects, the challenger platform solves the "Cold Start Problem" by delivering immediate "Single-Player Utility." Whether through internal data hygiene, specific vertical compliance (e.g., HIPAA for MedTech), or superior workflow automation, the platform provides value to the first user before a second partner ever joins. This document serves as an exhaustive guide for engineering leaders and product strategists, covering every layer of the stack from Postgres Row-Level Security (RLS) and trigram-based entity resolution to the Go-To-Market (GTM) execution required to disrupt a consolidated market.2. Market Landscape Analysis: The Post-Merger Reality2.1 The Rise of the SupernodeThe merger of Crossbeam and Reveal represents the maturity phase of the ELG market. By combining Crossbeamâ€™s robust data escrow infrastructure with Revealâ€™s intuitive mapping interface, the combined entity commands a significant majority of the market share. This "Supernode" benefits from classic network effects: the value of the platform increases non-linearly with every new participant, creating a formidable moat against new entrants attempting to clone the core "account mapping" functionality.1However, the creation of a monopoly-like incumbent invariably creates fissures. Analysis of G2 reviews and industry forums reveals a growing dissatisfaction with the "generalized" nature of the Supernode. Users express frustration with feature bloat, slow UI performance due to heavy client-side processing, and a support model that prioritizes enterprise accounts. More critically, the pricing structure has hardened, with essential features like real-time Salesforce write-back often gated behind five-figure enterprise contracts.42.2 The Execution Gap definedThe primary vulnerability of the current market leaders lies in the distance between insight and action.Data Rich, Process Poor: Ecosystem platforms have historically sold the promise of "unlocking hidden revenue." In practice, they deliver a CSV export of overlapping accounts. The actual work of co-sellingâ€”identifying the right stakeholder, requesting an introduction, tracking the referral, and attributing the revenueâ€”happens outside the platform. This friction results in "stalled overlaps," where potential deals die on the vine because the activation energy required to co-sell is too high.6The "Connector" Tax: Integration with CRMs is the lifeblood of these platforms. Yet, the incumbent model frequently treats integrations as a luxury add-on. For a mid-sized SaaS company, paying an additional $10,000+ merely to connect HubSpot or Salesforce creates a barrier to entry that prevents full ecosystem adoption.112.3 Competitive MatrixThe market is not monolithic. Several players occupy specific niches, though none have fully solved the execution problem for the mid-market using a lean, actionable approach.Feature / AttributeCrossbeam (The Supernode)PartnerTap (The Enterprise Tool)WorkSpan (The Hyperscaler)Proposed "Wedge" PlatformCore Value PropNetwork Effects & Data EscrowEnterprise Co-Sell AutomationHyperscaler (AWS/Azure) MgmtWorkflow Execution & ActionabilityPrimary TargetGeneral B2B SaaSLarge Enterprise / Channel TeamsGlobal Systems Integrators (GSIs)Mid-Market / Vertical SaaSPricing ModelFreemium -> High Platform FeePer-User / Enterprise LicenseProject/Listing Based FeesSeat-Based / Flat Platform FeeTech/UX FeelData Utility / DashboardComplex Enterprise SoftwareProject Management HeavyFast, App-Like, InteractiveImplementationLow friction (Standard Objects)High friction (Custom Mapping)Very High (Consultant led)Instant (Single-Player Value)Data PrivacyGeneral "Blind" MatchingEnterprise PermissionsProject-Specific AccessCompliance-as-Code (RLS)Execution GapHigh (Requires manual follow-up)Low (Automated but complex)Medium (Process heavy)Solved (Embedded Workflows)Table 1: Competitive Landscape Analysis 12.4 The Opportunity for DisruptionThe opportunity lies not in building a better data escrowâ€”Crossbeam has likely won that standardâ€”but in building a better operating system for partnerships. The "Wedge" platform does not need to replace Crossbeam initially; it can sit "on top" or "beside" it, handling the high-velocity execution that the incumbent ignores. By utilizing the Django + HAT stack, the challenger can iterate on these workflow features significantly faster than competitors burdened by technical debt and complex legacy codebases.3. The Wedge Strategy: Solving the Cold Start ProblemThe "Cold Start Problem," as articulated by Andrew Chen, describes the difficulty of launching a networked product where the utility is zero until others join. For a partner platform, this is the "Empty Room" scenario: a user signs up, connects their CRM, and sees... nothing, because they have no partners on the platform.16 To survive, the challenger must implement a Wedge Strategy that delivers "Single-Player Mode" value.3.1 Wedge 1: Internal Data Hygiene & Cross-SellBefore a company ever maps data with a partner, they often struggle to map data internally.The Use Case: A typical B2B company might have a Marketing Automation Platform (e.g., Marketo, HubSpot) and a Sales CRM (Salesforce). These databases are rarely perfectly synced. Marketing may be nurturing a lead that Sales has already disqualified or, conversely, unaware of a new key account Sales is targeting.The Solution: The platform positions itself initially as an "Internal Data Bridge." The user connects both their Marketing and Sales instances. The platform's entity resolution engine (discussed in Section 5) identifies overlaps within the company.Value Delivery: The user instantly sees "200 Marketing Leads that match Open Sales Opportunities." This justifies the investment immediately, purely on the basis of internal alignment and data hygiene, solving the cold start problem without a single external partner invitation.183.2 Wedge 2: Vertical Compliance (MedTech/FinTech)Generalist platforms like Crossbeam operate on a "Lowest Common Denominator" data schema, typically focusing on Website Domain as the primary identifier. This breaks down in industries where domains are irrelevant or insufficient.Healthcare (MedTech): In healthcare, the entity is often a "Provider" (Doctor) or a "Location" (Hospital Wing), identified by an NPI (National Provider Identifier) rather than a website. Furthermore, HIPAA regulations impose strict audit and data residency requirements.The Play: A Django-based platform can leverage Python's extensive healthcare data libraries (e.g., verifying NPI checksums) to build a schema specifically for this vertical. By marketing "HIPAA-Compliant Partner Mapping," the platform captures a lucrative market segment that the Supernode ignores due to complexity.19FinTech: Financial institutions often cannot let data leave their Virtual Private Cloud (VPC) or specific geographic region (e.g., GDPR data cannot move to a US server).The Play: An "Open Core" or "Self-Hosted" version of the platform, deliverable via Docker containers, allows FinTechs to run the mapping engine inside their own infrastructure. The HAT stack's simplicity makes this on-premise deployment far more manageable than a complex microservices architecture.213.3 Wedge 3: Actionability and The Chrome ExtensionThe third wedge focuses on the "Action" layer. Even if a user relies on Crossbeam for the data, they may use the Challenger platform for the workflow.The Trojan Horse: A free Chrome Extension that works on top of Salesforce or HubSpot.Mechanism: When a user visits a generic Account page in Salesforce, the extension (powered by the platform's API) lights up: "You have 3 partners who can help with this account."Viral Loop: The user installs the tool for the overlay. The tool then prompts them to invite those partners to the full platform to "unlock" the introductions. This drives bottom-up adoption, utilizing the extension as a distribution mechanism that bypasses the top-down sales cycle.84. Technical Architecture: The Django + HAT StackThe selection of the technology stack is not merely a preference; it is a strategic decision to enable high performance and rapid iteration with a lean team. The Django + HAT (HTMX, Alpine.js, Tailwind) stack is uniquely code-efficient for the specific challenges of a Co-Sell platform: massive data tables, complex filtering, and stateful dashboards.4.1 The Case for HAT over SPA (React/Vue)The prevailing trend in SaaS is the Single Page Application (SPA). However, for a data-heavy application like an ecosystem platform, SPAs introduce significant friction.State Management Hell: In a co-sell dashboard, the state (which accounts are visible, which filters are active, which partners are selected) is complex. Synchronizing this state between a client-side store (Redux/Pinia) and the server creates a "State Synchronization Gap."Performance Bottlenecks: Rendering a table with 5,000 rows in React requires complex virtualization (windowing) to maintain scroll performance. This complicates the DOM and often breaks native browser features (Ctrl+F).The HAT Advantage:HTMX (Hypertext Markup Extensions): Allows the server to render HTML partials. When a user filters the dashboard, the browser sends the filter parameters to Django. Django, leveraging the speed of Postgres, queries the data and returns only the HTML for the table rows. The browser swaps this HTML into the DOM. This "Server-Driven UI" ensures that the frontend never has to process the full dataset, keeping memory usage low and the interface snappy.24Alpine.js: Handles purely client-side interactions where a server round-trip is wastefulâ€”toggling a dropdown, closing a modal, or "Select All" logic. It provides the reactive feel of Vue.js without the build step or hydration complexity.26Tailwind CSS: Enables rapid UI development. In the context of Django templates, utility classes allow developers to style components inline, reducing the context switching between HTML and CSS files. This accelerates the "Idea to Feature" loop.284.2 Backend Design: Clean Architecture in DjangoTo support the complex business rules of data escrow (e.g., "User A can only see User B's data if both have opted in AND the overlap exists"), the Django project must adhere to Clean Architecture principles. relying solely on Django's default "Fat Model" or "Fat View" patterns will lead to unmaintainable spaghetti code as the platform scales.4.2.1 The Service LayerBusiness logic should be decoupled from the HTTP request/response cycle.Pattern: Create a services/ directory.Example: AccountMappingService.py handles the logic of triggering an overlap calculation. It does not know about HTTP requests or JSON. It accepts Python objects and returns Python objects.Python# services/mapping.py
def calculate_overlaps(tenant_a: Tenant, tenant_b: Tenant) -> int:
    # Domain logic for overlap
   ...
Benefit: This logic can be called from a Django View (for the UI), a Celery Task (for background processing), or a Management Command (for CLI administration) without code duplication. This is critical for the "API First" approach required for the Connector ecosystem.304.2.2 The Selector LayerReading data for a dashboard is fundamentally different from writing data.Pattern: Use selectors.py for complex read queries.Optimization: These selectors should return dictionaries or Data Classes (DTOs) rather than full Django Model instances.Why: Instantiating 10,000 Django Model objects is CPU-intensive. Fetching 10,000 dicts using .values() is orders of magnitude faster.Python# selectors/dashboard.py
def get_dashboard_overlaps(tenant_id: int) -> List:
    return Overlap.objects.filter(tenant_id=tenant_id).values('partner_name', 'account_count')
4.3 Multi-Tenancy Strategy: Row-Level Security (RLS)Security is the paramount feature. Users are entrusting the platform with their entire CRM database. The architecture must guarantee Data Isolation.4.3.1 RLS vs. Schema-Per-TenantWhile creating a separate Postgres schema for every tenant guarantees isolation, it creates a maintenance nightmare (running migrations across 5,000 schemas) and resource fragmentation (connection pooling issues).The Choice: Shared Database with Postgres Row-Level Security (RLS).Implementation:Every sensitive table (Account, Opportunity, Contact) has a tenant_id column.A Postgres Policy is defined: CREATE POLICY tenant_isolation ON accounts USING (tenant_id = current_setting('app.current_tenant')::int);Django Middleware: A custom middleware intercepts every request, identifies the tenant (via subdomain or session), and sets the Postgres variable: SET app.current_tenant = '123';.Benefit: Even if a developer forgets to add .filter(tenant=request.tenant) in a query, the database kernel blocks access to other tenants' data. This "Defense in Depth" is a powerful selling point for security reviews.324.4 Asynchronous Workflows (Celery + Redis)Co-selling data operations are heavy. Ingesting 500,000 accounts from Salesforce or running a fuzzy match algorithm cannot happen in the HTTP request loop.Architecture:Broker: Redis is the message broker for Celery.Workflow Canvas: Use Celery Canvas (chain, group, chord) to orchestrate complex pipelines.Example Workflow: Ingest Salesforce -> Normalize Data -> Hash PII -> Calculate Overlaps -> Update Materialized View -> Notify User.Visibility: The status of these tasks is written to Redis. The Frontend (HTMX) polls an endpoint that reads this status from Redis to update a progress bar, providing a "Real-Time" feel to long-running background processes.345. The Data Engine: Ingestion, Resolution, and MatchingThe platform's utility is entirely dependent on its ability to ingest data reliably and match it accurately.5.1 CRM Ingestion StrategyIntegrating with Salesforce and HubSpot is non-trivial due to API rate limits and data volume.5.1.1 Salesforce Bulk API 2.0For the initial load of a tenant's data, the standard REST API is insufficient.Constraint: The Salesforce REST API has a rolling 24-hour limit (often as low as 15,000 calls). Fetching 100,000 accounts page-by-page will exhaust this immediately.36Solution: Use the Salesforce Bulk API 2.0.The Django backend submits a "Query Job" (e.g., SELECT Id, Name, Website FROM Account).Salesforce processes this asynchronously and generates a CSV file.The platform downloads and streams this CSV into the DB.Efficiency: This consumes only one API call per batch of data, regardless of size.375.1.2 Incremental Sync & Deletion HandlingAfter the initial load, the platform must keep data in sync.The Delta: Use the SystemModstamp field in Salesforce or hs_lastmodifieddate in HubSpot to fetch only records changed since the last sync.The Hard Delete Problem: Incremental syncs typically query for updates. If a record is deleted in Salesforce, it simply disappears; it doesn't show up in an "updated" query.Solution: Periodically query the getDeleted() replication endpoint (Salesforce) or check against a "known IDs" list (HubSpot) to identify and remove stale records. Failing to do this leads to "Ghost Overlaps"â€”matches with companies that are no longer customers.385.2 Entity Resolution: The Matching CoreThe core intellectual property (IP) of the platform is the matching algorithm. How do we know "Acme" is "Acme, Inc."?5.2.1 Deterministic vs. Probabilistic MatchingStage 1: Exact Domain Match (Deterministic):Normalize domains (strip www., http://).Match acme.com to acme.com. This is fast ($O(1)$) and highly accurate.Stage 2: Fuzzy Name Match (Probabilistic):Required when domains are missing or generic (e.g., gmail.com).Algorithm: We utilize Postgres Trigrams (pg_trgm). This extension breaks strings into three-letter sequences.Example: "Apple" ->   a,  ap, app, ppl, ple, le .Indexing: Create a GIN (Generalized Inverted Index) on the normalized_name column. This allows Postgres to perform fuzzy searches effectively instantly on millions of rows.Scoring: We define a threshold (e.g., 0.8). If the similarity score is > 0.8, it is considered a candidate match.395.2.2 The Blocking StrategyComparing every record to every other record is an $O(N^2)$ operation, which is computationally prohibitive.Blocking: We divide the dataset into "Blocks" based on loose criteria (e.g., "First 2 letters of Name" + "State").Logic: We only run the expensive fuzzy match algorithm on pairs within the same block. This reduces the search space drastically, allowing the matching job to complete in minutes rather than hours.425.3 Materialized Views for PerformanceOnce overlaps are calculated, they must be queried instantly by the dashboard.The Problem: Running the match query in real-time is too slow.The Solution: Store the results in a Materialized View.Refresh Strategy: Standard materialized views require a full refresh. We employ Incremental View Maintenance (IVM) concepts. When a batch of 50 accounts is updated, a trigger recalculates matches only for those 50 accounts and updates the view. This ensures the dashboard data is always fresh without the heavy load of a full system re-index.446. Frontend Patterns: The "App-Like" ExperienceTo compete with slick SPAs, the Django + HAT implementation must feel responsive.6.1 Real-Time Dashboards with HTMXThe user expects to see the progress of their data sync.Implementation:HTML<div hx-get="/api/sync-progress/{job_id}"
     hx-trigger="every 2s"
     hx-swap="innerHTML">
   <div class="w-full bg-gray-200 rounded-full h-2.5">
     <div class="bg-blue-600 h-2.5 rounded-full" style="width: {{ progress }}%"></div>
   </div>
   <span class="text-sm">{{ status_message }}</span>
</div>
Mechanism: The browser polls the endpoint every 2 seconds. Django checks Redis for the job status and renders the progress bar HTML. When the job completes (progress == 100), the endpoint returns the final "Sync Complete" UI with a trigger to load the main data table. This pattern is robust and requires zero client-side JavaScript logic.246.2 Complex Filtering with Alpine.jsUsers need to filter overlaps by multiple criteria (Revenue, Region, Partner Status).Challenge: Sending a request for every single checkbox click creates a "jumpy" UI.Solution: Use Alpine.js to manage the "Filter State" locally.User toggles multiple checkboxes. Alpine updates a hidden input field or local state object.User clicks "Apply Filters."HTMX sends the aggregated state to the server.This hybrid approach gives the responsiveness of a client-side app (immediate visual feedback on clicks) with the performance of server-side data processing.277. Security Architecture: The Trust FrameworkIn the ecosystem market, trust is the product. If a user believes their data might leak to a competitor, the platform fails.7.1 Data Escrow and "Blind" HashingTo support the core promise of "I only see what overlaps," the architecture implements a Double-Blind Hashing protocol.Process:Upon ingestion, critical identifiers (Email, Domain) are hashed using a salted SHA-256 algorithm.The raw data is encrypted and stored in the Tenant's RLS-protected partition.The hashed values are stored in a separate index optimized for matching.The Match: The matching engine compares Hash(A) to Hash(B).The Reveal: Only if a match occurs does the system retrieve the metadata (Name, Owner) associated with that hash.Benefit: This architecture ensures that even the database administrators have limited visibility into the non-overlapping data, a key requirement for SOC 2 Type II compliance.467.2 Chrome Extension SecurityThe Chrome Extension is a high-risk vector because it runs in the user's browser context.Manifest V3 Compliance: The extension must strictly adhere to Manifest V3, which disallows remote code execution.No Sensitive Logic in Client: The extension should treat the browser as "untrusted." It should not perform matching logic locally.Flow:Extension extracts the current page domain (acme.com).Extension sends a hash of the domain to the Django API.API checks RLS permissions and overlap status.API returns a simple status object ({has_overlap: true, count: 3}).Extension renders the notification.Security: This ensures that the user's full partner list is never downloaded to the browser, preventing scraping attacks.238. Go-To-Market (GTM) Strategy: Disruption Execution8.1 Pricing Strategy: The "Connector" ArbitrageThe incumbent (Crossbeam/Reveal) model typically charges a premium for "Connectors" (API access to Salesforce/HubSpot) or tiers pricing based on revenue. This acts as a "tax on success."The Challenger Pricing:Feature Parity: Offer full Connector access in the entry-level paid tier (e.g., $199/month). This commoditizes the incumbent's primary upsell driver.Seat-Based Monetization: Charge based on the number of "Active Co-Sellers" (Sales Reps accessing the data). This aligns pricing with value (revenue generation) rather than data volume.Freemium Wedge: The "Internal Data Hygiene" tool (Wedge 1) is free forever. This fills the top of the funnel with users who have already integrated their data, lowering the friction to upgrade to the full ecosystem platform.118.2 Distribution: The "Co-Sell Agency" ChannelA largely untapped distribution channel is the growing ecosystem of "Partnership Consultants" and Agencies.The Problem: Consultants struggle to demonstrate ROI to their clients because the incumbent tools are too expensive for early-stage programs.The Solution: Offer an "Agency Edition" of the platform.Multi-Tenant Admin: Consultants can manage 10 different client instances from a single login.Agency Pricing: A discounted bulk rate allows the consultant to bundle the software cost into their retainer.Impact: The consultants become the platform's sales force, incentivized to deploy it to every new client they sign.8.3 Partner Attribution: The Metric of TruthTo displace the incumbents, the platform must prove it drives revenue.Sourced vs. Influenced: The platform must distinguish between "Partner Sourced" (Partner brought the lead) and "Partner Influenced" (Partner helped close the deal).Implementation:Time Decay Model: If a partner activity (Intro, Meeting) occurred within X days of a deal closing, the platform automatically attributes a percentage of "Influence" credit.Write-Back: This data is pushed back to the Salesforce Opportunity object. When the VP of Sales runs their "Revenue by Source" report in Salesforce, the "Partner Ecosystem" bar appears significantly larger. This visibility is the ultimate retention mechanism.489. ConclusionThe consolidation of the Partner Ecosystem market into a Supernode has not ended the competition; it has clarified the battlefield. The incumbents have chosen the path of "Data Utility"â€”broad, passive, and expensive. This leaves a massive opening for a "Co-Sell Execution" platformâ€”focused, active, and accessible.By leveraging the Django + HAT stack, the proposed platform achieves the technical velocity to out-pace incumbents on workflow features while maintaining the robust data architecture required for enterprise scale. The Wedge Strategy ensures that the platform provides immediate value to the first user, breaking the Cold Start deadlock that kills most network-effect startups. This blueprint represents not just a technical architecture, but a strategic roadmap to disrupt the ecosystem economy by solving the one problem that matters most: turning data into revenue.


This is a comprehensive and well-structured plan that correctly identifies the "Execution Gap" in the current ecosystem market. The other LLM has produced a viable path to an MVP. However, as your expert team, we have analyzed this plan against technical realities and market dynamics.

Here is our executive review and critical analysis of the proposed plan.

1. Strategic Analysis: The "Build vs. Wrapper" Risk
The Verdict: The plan selects the "Execution OS" wedge (right choice) but couples it with a "Build the Data Engine from Scratch" strategy (high risk).

The Contradiction: The plan argues that the unique value proposition (UVP) is actionability (Slack alerts, intro workflows), yet the Execution Plan allocates the first 60 days to rebuilding commodity infrastructure (data ingestion, identity resolution, and matching).

The Trap: By building the matching engine from scratch, you compete directly with Crossbeamâ€™s core moat immediately. You risk spending 4 months tuning fuzzy matching algorithms before a single user sends an intro request.

Alternative Recommendation: Consider a "Sidecar" approach for the true MVP. Ingest CSV exports from Crossbeam/Reveal or use their basic APIs to populate your "Action" layer. This allows you to validate the workflow (Intro Requests, Slack pings) in Week 2, not Month 3. Once users are addicted to the workflow, then you build the native matching engine to replace the CSV import.

2. Technical Architecture Audit (Django + HAT)
Strengths:

Stack Selection: The choice of Django + HTMX + Alpine.js is excellent for this domain. It avoids the state synchronization headaches of React SPAs when dealing with massive data tables.

Postgres Trigrams: Using pg_trgm for fuzzy matching is the correct architectural decision for a startup, avoiding the complexity of Elasticsearch or dedicated entity resolution services.

Critical Weaknesses & Fixes:

RLS Performance: The plan suggests RLS (Row-Level Security) is a "best practice." While true for security, RLS imposes a performance penalty on every query because policies are evaluated row-by-row. Benchmarks show this can degrade performance by 10-30% on complex joins.

Fix: Ensure you index the tenant_id column on every table and include it in every composite index.

Matching Scalability (The O(N*M) Problem): The plan glosses over the computational cost of fuzzy matching. Doing a trigram comparison on 100k rows against 100k rows is computationally expensive.

Fix: You must implement blocking. Only fuzzy match rows that share a "block" (e.g., same State or first 2 letters of name). Do not run open-ended fuzzy joins.

Incremental Updates: The plan mentions "incremental sync," but Postgres Materialized Views do not support incremental updates out of the box (they require full refreshes).

Fix: Use the pg_ivm extension if possible, or build a custom "Delta" table approach where you only re-calculate matches for accounts with a last_modified > last_sync timestamp.

3. Market & Competitive Critique
The Pricing Gap:

The plan suggests a Pro tier at ~$1,000/month.

Reality Check: Crossbeamâ€™s "Connector" plan is ~$150/user/month. If a mid-market team has 2 users, they pay Crossbeam $300/mo. Your price of $1,000/mo creates friction.

Recommendation: Align pricing to successful outcomes (e.g., $X per accepted intro) or a lower per-seat base to undercut the "tax" incumbents charge.

The "Cold Start" Wedge:

The plan relies on "Invite a Partner" to get value. This is the hardest friction point.

Missed Wedge: The "Internal Data Hygiene" wedge (Wedge 1 in your prompt options) is undervalued. Identifying overlaps between a user's own HubSpot and Salesforce instances (e.g., "Active Prospect in HubSpot is already a Customer in Salesforce") provides single-player value immediately, without needing a partner to sign up.

4. Detailed Feature Audit (Red/Yellow/Green)
Feature	Assessment	Notes
Identity Resolution	ðŸŸ¡ Yellow	
pg_trgm needs strict threshold tuning (e.g., 0.7-0.8) or it generates noise. Plan needs an "Unmatch" UI for users to fix bad matches.

Salesforce Sync	ðŸ”´ Red	
The plan underestimates API limits. SFDC REST API has strict 24h rolling limits. You must use the Bulk API 2.0 for initial loads, or you will break the customer's CRM.

Slack Integration	ðŸŸ¢ Green	
Good focus. Slack Block Kit  is the right way to handle "Accept/Reject" buttons directly in the chat.

Chrome Extension	ðŸŸ¡ Yellow	
Security risk. Storing full overlap data in the browser is dangerous. The extension should send a hash of the domain to the server and receive a simple "True/False" response.

5. Final Verdict & Key Revisions
The plan is 85% executable but risks stalling in the "build phase" of the data engine.

Immediate Actions to De-Risk:

Pivot MVP Ingestion: Support CSV upload of existing Crossbeam/Reveal exports. "Bring your existing overlaps and we make them actionable."

Hard-Code Matching Thresholds: Don't build a complex probabilistic model initially. Use strict normalization + exact domain matching. It is better to miss a match than to suggest a false positive (which destroys trust).

Refine Pricing: Drop the $1k/mo floor. Offer a "Single Player" tier for $200/mo that focuses on internal data mapping or simple CSV-based partner mapping.

This plan successfully architects a modern SaaS using the right stack (Django/HAT), but it underestimates the difficulty of replacing the incumbent's primary moat (the data network). Focus the engineering effort on the workflow (the Automation Engine), not the data warehouse.



You can copy the content below into a file named PROJECT_CONTEXT.md in your root directory.

Then, when you start a chat in Cursor, you can reference this file (by typing @PROJECT_CONTEXT.md) so the AI knows exactly what to build, the architectural constraints, and the roadmap.

PROJECT CONTEXT: Sidecar Co-Sell Execution Engine
1. Project Overview
Goal: Build a "Sidecar Execution Engine" for ecosystem-led growth. Unlike competitors that focus on finding data overlaps, we focus on acting on them. The "Wedge" Strategy:

Single-Player Mode (Day 0): Users connect their own Salesforce & HubSpot. We find internal disconnects (e.g., "HubSpot Prospect" is already a "Salesforce Customer").

Sidecar Mode (Day 1): Users upload CSV exports from Crossbeam/Reveal. We auto-generate Slack alerts, CRM tasks, and Intro Emails based on that static data.

No "Network" Required: We do not require partners to sign up to deliver value.

2. Technical Stack (The "HAT" Stack)
Backend: Python 3.11+, Django 5.x

Database: PostgreSQL 16+ (Host: AWS RDS or DigitalOcean Managed)

Frontend: HTMX (Server-Side Rendering), Alpine.js (Lightweight interactivity), TailwindCSS (Styling)

Async/Queue: Celery + Redis

Infrastructure: Docker, gunicorn, whitenoise

3. Critical Architecture Decisions (Non-Negotiable)
A. Multi-Tenancy & RLS (Row-Level Security)
We use a Shared Database, Shared Schema approach with Postgres Row-Level Security for isolation.

Rule 1: Every sensitive model (Account, Overlap, Contact) MUST have a tenant_id field (ForeignKey to Organization).

Rule 2: We use a Django Middleware to set SET app.current_tenant = '...' on every request.

Rule 3 (Performance): Every index on RLS-protected tables MUST be a Composite Index starting with tenant_id.

Bad: CREATE INDEX idx_email ON contacts(email);

Good: CREATE INDEX idx_tenant_email ON contacts(tenant_id, email);

Rule 4 (Connection Pooling): Use Session Pooling (PgBouncer). Transaction pooling breaks RLS unless specifically handled.

B. Ingestion Strategy
Salesforce: MUST use Bulk API 2.0 for all batch operations to avoid hitting 24h API limits. Do not iterate page-by-page.

CSV Imports: Use Python pandas or csv module with strict validation. Map columns to a unified "Staging Table" before processing into Account records.

C. No-Fuzzy Matching (MVP)
Phase 1: Only use Exact Domain Matching (normalize URL -> extract root domain -> match).

Phase 2: Do not build a complex entity resolution engine yet. Trust the IDs provided in Crossbeam/Reveal CSV uploads.

4. Core Data Models (Schema)
organizations App
Organization: The Tenant. Fields: name, domain, plan_tier.

User: Extended Django User. Fields: organization (FK).

integrations App
Integration: Stores OAuth tokens. Fields: organization (FK), provider (salesforce, hubspot, slack), credentials (Encrypted JSON), status.

data App (RLS Protected)
Account: A company record.

Fields: tenant_id, source_system (SFDC/HubSpot), external_id, name, domain (normalized), status (Customer/Prospect/Churned), owner_email.

Constraint: Composite Index (tenant_id, domain).

Overlap: A match between internal data or external partner data.

Fields: tenant_id, my_account (FK), partner_name (Char), partner_account_name (Char), partner_status (Char), source (CSV_Upload / Internal_Match).

automation App
Action: A unit of work generated by the system.

Fields: tenant_id, overlap (FK), type (Slack_Alert, CRM_Task, Email_Draft), status (Pending, Sent, Failed), payload (JSON).

AutomationRule: Logic for triggers.

Fields: tenant_id, trigger_event (New_Overlap), conditions (JSON: {"partner_status": "Customer", "my_status": "Prospect"}), action_config (JSON).

5. Implementation Roadmap (Next 3 Steps)
Step 1: The "Internal Hygiene" Engine
Task: Build the Django project structure.

Task: Implement the RLSMiddleware and Tenant model.

Task: Build the "Domain Normalizer" utility (removes www., https://).

Task: Build the InternalMatcher service: Query HubSpot Accounts and Salesforce Accounts where domain matches but lifecycle_stage is conflicting.

Step 2: The Universal CSV Importer
Task: Create a UI (HTMX file upload) that accepts a CSV.

Task: Create a "Mapper" view where user selects which column maps to "Partner Name", "Account Name", "Website".

Task: Ingest rows into the Overlap table.

Step 3: The "Action" Loop
Task: Connect Slack App (OAuth).

Task: Create a Celery task process_automation_rules.

Task: When a new Overlap is created, check Rules -> if match -> Send Slack DM to the Account Owner via Block Kit.

6. Coding Guidelines for AI
HTMX: Use hx-post, hx-target, and hx-swap for all form submissions. Do not write React.

Tailwind: Use utility classes directly in Django templates.

Simplicity: If logic is complex, move it to services.py inside the app. Keep Views thin.

Security: Never print/log raw OAuth tokens. Always assume multi-tenancy constraints apply.